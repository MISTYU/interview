## 前端灰度发布方案

> 按流量百分比；按地区；用户id；活动id；按ip；等等

从部分到全量逐步的过程

### nginx + lua + apollo
推荐指数：⭐⭐⭐⭐

成本：⭐⭐⭐

具体做法：用户请求 nginx,nginx 根据灰度策略判断当前用户需要渲染的版本后返回对应版本的 html， 判断版本的逻辑由 nginx 处理，灰度策略存放在某个数据库或者 apollo（比如白名单 ip,白名单 id，百分比值）

优势：
* 不改动前端业务代码，维护简单

劣势：
* 改造成本稍大，需要后端或者运维支援、需要使用 lua 语言，可能需要修改构建流程

### bff + apollo
推荐指数：⭐⭐⭐

成本：⭐⭐⭐⭐

具体做法：类似第一种，只是把 nginx 换成了 node.js,适合有 bff 层，且 bff 承担渲染前端页面功能的项目

优势：
* 不改动前端业务代码，维护简单

劣势：
* 对于没有 bff 的项目或者有 bff 但不承担渲染任务的项目，改造成本大，需要引入 bff 层

### 前端自己做资源的入口判断
推荐指数：⭐⭐⭐

成本：⭐

具体做法：用户请求 nginx，nginx 返回 html ，前端渲染 html, 执行 script 脚本，前端判断灰度的版本号，最后动态加载不同版本的入口 main.js。在这里灰度策略、灰度版本判断逻辑都放在前端 html 内的 script 脚本处理。

优势：
* 无需后端运维参与改造
* 项目级别的灰度，不修改具体的业务代码

劣势：
* 需要灰度的时候，需要前端修改，增加前端工作量

### 前端业务代码逻辑判断
推荐指数：不推荐

成本：⭐⭐⭐⭐⭐

具体做法：前端在代码里面 if else 判断，例如 A用户使用 A 组件，B 用户使用 B 组件

优势：
* 纯前端

劣势：
* 不适合项目级别控制的 A/B test，只适用于组件级别
* 代码冗余，可能有多版本，多个 if 判断 ，维护麻烦

### 总结
> 灰度发布的本质问题其实就 3 个
1. 打包的资源怎么处理
* 上传到 cdn
可以通过资源地址的 hash 值判断
* 放到云服务器
需要每次打包出来的目录名不一致，然后根据资源目录名称，本质也是地址 hash 不同
* docker 镜像
通过镜像的版本号来判断

2. 灰度策略放在哪里
* 放到后端业务的数据库
* apollo
* 前端

3. 灰度版本的判断逻辑放在哪
* 可以放到 nginx
* 可以放到 BFF（Node.js）
* 可以放到前端
